<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title id="title">Marching Cubes</title>
<script src="https://cdn.rawgit.com/toji/gl-matrix/v3.3.0/dist/gl-matrix.js"></script>
<script src="https://legacygl-js.glitch.me/gl-matrix-util.js"></script>
<script src="https://legacygl-js.glitch.me/legacygl.js"></script>
<script src="https://legacygl-js.glitch.me/drawutil.js"></script>
<script src="https://legacygl-js.glitch.me/camera.js"></script>
<script src="https://legacygl-js.glitch.me/util.js"></script>
<script src="https://legacygl-js.glitch.me/glu.js"></script>
<script type="text/javascript">
var gl;
var canvas;
var legacygl;
var drawutil;
var camera;

const minpoint = [-5.0, -5.0, -5.0];
const maxpoint = [5.0, 5.0, 5.0];
const resolution = [10, 10, 10];
const width = vec3.divide_ip(vec3.sub([], maxpoint, minpoint), resolution);

function sphere(p) {
    const R = 4.5;
    return vec3.sqrLen(p) - R * R;
}

function torus(p) {
    const x = p[0];
    const y = p[1];
    const z = p[2];
    const R = 3.5;
    const a = 1.0;
    return (x * x + y * y + z * z + R * R - a * a) ** 2 - 4.0 * R * R * (x * x + z * z);
}

function nazo(p) {
    const x = p[0];
    const y = p[1];
    const z = p[2];
    return 0.2 * (2.0 * y * (y * y - 3.0 * x * x) * (1.0 - z * z) + (x * x + y * y) ** 2 - (9.0 * z * z - 1.0) * (1.0 - z * z));
}

function ring(p) {
    const x = p[0];
    const y = p[1];
    const z = p[2];
    const R = 4.5;
    const a = 1.4;
    const c = 10.0;
    const temp = (x * x + y * y + z * z + R * R - a * a) ** 2;
    const f1 = temp - 4.0 * R * R * (x * x + y * y);
    const f2 = temp - 4.0 * R * R * (y * y + z * z);
    const f3 = temp - 4.0 * R * R * (z * z + x * x);
    return f1 * f2 * f3 - c; 
}

function Tetrahedron(cube, i1, i2, i3, i4) {
    const ls = [i1, i2, i3, i4];
    this.vertices = ls.map(i => cube.vertices[i]);
    this.vertex_values = ls.map(i => cube.vertex_values[i]);
    this.mid = (i, j) => {    // functionはだめ。アロー関数のスコープ。thisが変わっちゃう。
        const v1 = this.vertices[i];
        const v2 = this.vertices[j];
        const value1 = this.vertex_values[i];
        const value2 = this.vertex_values[j];
        if ((value1 > 0.0 && value2 > 0.0) || (value1 < 0.0 && value2 < 0.0)) {
            return undefined;    // 利用しないので計算する必要はない
        } else if (value1 == value2) {
            return vec3.scale_ip(vec3.add([], v1, v2), 0.5);
        } else {
            return vec3.scale_ip(vec3.sub([], vec3.scale([], v2, value1), vec3.scale([], v1, value2)), 1.0 / (value1 - value2));
        }
    };
    // this.edge_midpoints =
    //     [this.mid(0, 1), mid(0, 2), mid(0, 3), 
    //      mid(1, 2), mid(2, 3), mid(3, 0)];
}

function generateTetrahedra(cube) {
    return [new Tetrahedron(cube, 0, 2, 3, 7),
            new Tetrahedron(cube, 0, 2, 6, 7),
            new Tetrahedron(cube, 0, 4, 6, 7),
            new Tetrahedron(cube, 0, 6, 1, 2),
            new Tetrahedron(cube, 0, 6, 1, 4),
            new Tetrahedron(cube, 5, 6, 1, 4)];  
}

function Cube(centre, f) {
    const x = centre[0];
    const y = centre[1];
    const z = centre[2];
    const halfwidth_x = 0.5 * width[0];
    const halfwidth_y = 0.5 * width[1];
    const halfwidth_z = 0.5 * width[2];
    this.vertices = 
        [[x - halfwidth_x, y - halfwidth_y, z - halfwidth_z],
         [x + halfwidth_x, y - halfwidth_y, z - halfwidth_z],
         [x + halfwidth_x, y + halfwidth_y, z - halfwidth_z],
         [x - halfwidth_x, y + halfwidth_y, z - halfwidth_z],
         [x - halfwidth_x, y - halfwidth_y, z + halfwidth_z],
         [x + halfwidth_x, y - halfwidth_y, z + halfwidth_z],
         [x + halfwidth_x, y + halfwidth_y, z + halfwidth_z],
         [x - halfwidth_x, y + halfwidth_y, z + halfwidth_z]];
    this.vertex_values = this.vertices.map(f);
}

function draw() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // projection & camera position
    mat4.perspective(legacygl.uniforms.projection.value, Math.PI / 6, canvas.aspect_ratio(), 0.1, 1000);
    var modelview = legacygl.uniforms.modelview;
    camera.lookAt(modelview.value);
    // zx grid
    legacygl.color(0.5, 0.5, 0.5);
    drawutil.zxgrid(50);
    // draw
    // legacygl.color(1, 0.6, 0.2);
    for (var i = 0; i < resolution[0]; i++) {
        for (var j = 0; j < resolution[1]; j++) {
            for (var k = 0; k < resolution[2]; k++) {
                const x = width[0] * (i + 0.5) + minpoint[0];
                const y = width[1] * (j + 0.5) + minpoint[1];
                const z = width[2] * (k + 0.5) + minpoint[2];
                const centre = [x, y, z];
                const f = sphere;
                const cube = new Cube(centre, f);
                const tetrahedra = generateTetrahedra(cube);
                tetrahedra.forEach(function(t) {
                    var index = 0;
                    for (var l = 0; l < 4; l++) {
                        index |= (t.vertex_values[l] < 0 ? 1 : 0) << l;
                    }
                    legacygl.color(0.9, 0.9, 0.2);
                    legacygl.begin(gl.TRIANGLES);
                    if (index == 1 || index == 14) {
                        legacygl.vertex3(t.mid(0, 1));
                        legacygl.vertex3(t.mid(0, 2));
                        legacygl.vertex3(t.mid(0, 3));
                    } else if (index == 2 || index == 13) {
                        legacygl.vertex3(t.mid(1, 2));
                        legacygl.vertex3(t.mid(1, 3));
                        legacygl.vertex3(t.mid(1, 0));
                    } else if (index == 4 || index == 11) {
                        legacygl.vertex3(t.mid(2, 3));
                        legacygl.vertex3(t.mid(2, 0));
                        legacygl.vertex3(t.mid(2, 1));
                    } else if (index == 7 || index == 8) {
                        legacygl.vertex3(t.mid(3, 0));
                        legacygl.vertex3(t.mid(3, 1));
                        legacygl.vertex3(t.mid(3, 2));
                    } else if (index == 3 || index == 12) {
                        legacygl.vertex3(t.mid(0, 3));
                        legacygl.vertex3(t.mid(0, 2));
                        legacygl.vertex3(t.mid(1, 3));
                        legacygl.vertex3(t.mid(1, 3));
                        legacygl.vertex3(t.mid(1, 2));
                        legacygl.vertex3(t.mid(0, 2));
                    } else if (index == 5 || index == 10) {
                        legacygl.vertex3(t.mid(0, 1));
                        legacygl.vertex3(t.mid(2, 3));
                        legacygl.vertex3(t.mid(0, 3));
                        legacygl.vertex3(t.mid(0, 1));
                        legacygl.vertex3(t.mid(1, 2));
                        legacygl.vertex3(t.mid(2, 3));
                    } else if (index == 6 || index == 9) {
                        legacygl.vertex3(t.mid(0, 1));
                        legacygl.vertex3(t.mid(1, 3));
                        legacygl.vertex3(t.mid(2, 3));
                        legacygl.vertex3(t.mid(0, 1));
                        legacygl.vertex3(t.mid(0, 2));
                        legacygl.vertex3(t.mid(2, 3));
                    }
                    legacygl.end();
                })
                // for (var m = 0; ; m += 3) {
                //     if (triangleList[m] < 0) break;
                //     legacygl.color(1, 0.6, 0.2);
                //     legacygl.begin(gl.LINE_STRIP);
                //     legacygl.vertex3(cube.edge_midpoints[triangleList[m]]);
                //     legacygl.vertex3(cube.edge_midpoints[triangleList[m + 1]]);
                //     legacygl.vertex3(cube.edge_midpoints[triangleList[m + 2]]);
                //     legacygl.end();
                //     legacygl.color(0.9, 0.9, 0.2);
                //     legacygl.begin(gl.TRIANGLES);
                //     legacygl.vertex3(cube.edge_midpoints[triangleList[m]]);
                //     legacygl.vertex3(cube.edge_midpoints[triangleList[m + 1]]);
                //     legacygl.vertex3(cube.edge_midpoints[triangleList[m + 2]]);
                //     legacygl.end();
                // }
            }
        }
    }
    // legacygl.begin(gl.TRIANGLES);
    // legacygl.vertex3([1.0, 1.0, 1.0]);
    // legacygl.vertex3([1.0, 2.0, 1.0]);
    // legacygl.vertex3([2.0, 1.0, 2.0]);
    // legacygl.vertex3([1.0, 1.0, -1.0]);
    // legacygl.vertex3([1.0, 2.0, -1.0]);
    // legacygl.vertex3([2.0, 1.0, -2.0]);
    // legacygl.end();
};

function init() {
    // OpenGL context
    canvas = document.getElementById("canvas");
    gl = canvas.getContext("experimental-webgl");
    if (!gl)
        alert("Could not initialise WebGL, sorry :-(");
    var vertex_shader_src = "\
        attribute vec3 a_vertex;\
        attribute vec3 a_color;\
        varying vec3 v_color;\
        uniform mat4 u_modelview;\
        uniform mat4 u_projection;\
        void main(void) {\
            gl_Position = u_projection * u_modelview * vec4(a_vertex, 1.0);\
            v_color = a_color;\
            gl_PointSize = 5.0;\
        }\
        ";
    var fragment_shader_src = "\
        precision mediump float;\
        varying vec3 v_color;\
        void main(void) {\
            gl_FragColor = vec4(v_color, 1.0);\
        }\
        ";
    legacygl = get_legacygl(gl, vertex_shader_src, fragment_shader_src);
    legacygl.add_uniform("modelview", "Matrix4f");
    legacygl.add_uniform("projection", "Matrix4f");
    legacygl.add_vertex_attribute("color", 3);
    legacygl.vertex3 = function(p) {
        this.vertex(p[0], p[1], p[2]);
    };
    drawutil = get_drawutil(gl, legacygl);
    camera = get_camera(canvas.width);
    camera.eye = [15, 12, 20];
    // event handlers
    canvas.onmousedown = function(evt) {
        var mouse_win = this.get_mousepos(evt);
        camera.start_moving(mouse_win, evt.shiftKey ? "zoom" : evt.ctrlKey ? "pan" : "rotate");
    };
    canvas.onmousemove = function(evt) {
        var mouse_win = this.get_mousepos(evt);
        if (camera.is_moving()) {
            camera.move(mouse_win);
            draw();
        }
    };
    document.onmouseup = function (evt) {
        if (camera.is_moving()) {
            camera.finish_moving();
        }
    };
    // init OpenGL settings
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(1, 1, 1, 1);
};
</script>
</head>
<body onload="init(); draw();">
  <h2><script type="text/javascript">document.write(document.getElementById("title").innerHTML);</script></h2>
  <canvas id="canvas" width="640" height="480" style="border:1px solid #000000"></canvas>
  <h3>Usage:</h3>
  <ul>
    <li>Drag: Camera Rotate</li>
    <li>Shift+drag: Camera Zoom</li>
    <li>Ctrl+drag: Camera Pan</li>
  </ul>
</body>
</html>
