<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title id="title">Marching Cubes, Marching Tetrahedra</title>
<script src="https://cdn.rawgit.com/toji/gl-matrix/v3.3.0/dist/gl-matrix.js"></script>
<script src="https://legacygl-js.glitch.me/gl-matrix-util.js"></script>
<script src="https://legacygl-js.glitch.me/legacygl.js"></script>
<script src="https://legacygl-js.glitch.me/drawutil.js"></script>
<script src="https://legacygl-js.glitch.me/camera.js"></script>
<script src="https://legacygl-js.glitch.me/util.js"></script>
<script src="https://legacygl-js.glitch.me/glu.js"></script>
<script src="./marching-cubes.js"></script>
<script type="text/javascript">
var gl;
var canvas;
var legacygl;
var drawutil;
var camera;

// minpointからmaxpointまでの空間を解像度resolutionで分割
const minpoint = [-5.0, -5.0, -5.0];
const maxpoint = [5.0, 5.0, 5.0];
var resolution = [10, 10, 10];
var width = vec3.divide_ip(vec3.sub([], maxpoint, minpoint), resolution);

// 図形一覧
function sphere(p) {
    const R = 4.5;
    return vec3.sqrLen(p) - R * R;
}
function torus(p) {
    const x = p[0];
    const y = p[1];
    const z = p[2];
    const R = 3.5;
    const a = 1.0;
    return (x * x + y * y + z * z + R * R - a * a) ** 2 - 4.0 * R * R * (x * x + z * z);
}
function cone(p) {
    const x = p[0];
    const y = p[1];
    const z = p[2];
    return x * x + z * z - 0.25 * (y - 5.0) * (y - 5.0) - 0.02;
}
function glass(p) {
    const x = p[0];
    const y = p[1];
    const z = p[2];
    return x * x + z * z - Math.log(y + 5.1) * Math.log(y + 5.1) - 0.02;
}
function metaball(p) {    // TODO
    // return 1.2 / vec3.dist(p, [-2.5, 0.5, 2.5]) + 1.2 / vec3.dist(p, [2.5, -1.5, -2.5]) - 1.0;
    return 1.2 / vec3.dist(p, [-1.5, 0.5, 1.5]) + 1.2 / vec3.dist(p, [1.5, -1.5, -1.5]) - 1.0;
    // return 1.0 / vec3.dist(p, [-1.0, 0.5, 1.0]) - 1.5 / vec3.dist(p, [1.0, -0.5, -1.0]) - 0.2;
}

function vertices_midpoint(cell, i, j) {    // cellにおける頂点i,jの重み付き中点
    const v1 = cell.vertices[i];
    const v2 = cell.vertices[j];
    const value1 = cell.vertex_values[i];
    const value2 = cell.vertex_values[j];
    if ((value1 > 0.0 && value2 > 0.0) || (value1 < 0.0 && value2 < 0.0)) {
        return undefined;    // 利用しないので計算する必要はない
    } else if (value1 == value2) {
        return vec3.scale_ip(vec3.add([], v1, v2), 0.5);
    } else {
        return vec3.scale_ip(vec3.sub([], vec3.scale([], v2, value1), vec3.scale([], v1, value2)), 1.0 / (value1 - value2));
    }
}
function Cube(centre, figure) {    // 直方体セル
    const x = centre[0];
    const y = centre[1];
    const z = centre[2];
    const halfwidth_x = 0.5 * width[0];
    const halfwidth_y = 0.5 * width[1];
    const halfwidth_z = 0.5 * width[2];
    this.vertices = 
        [[x - halfwidth_x, y - halfwidth_y, z - halfwidth_z],
         [x + halfwidth_x, y - halfwidth_y, z - halfwidth_z],
         [x + halfwidth_x, y + halfwidth_y, z - halfwidth_z],
         [x - halfwidth_x, y + halfwidth_y, z - halfwidth_z],
         [x - halfwidth_x, y - halfwidth_y, z + halfwidth_z],
         [x + halfwidth_x, y - halfwidth_y, z + halfwidth_z],
         [x + halfwidth_x, y + halfwidth_y, z + halfwidth_z],
         [x - halfwidth_x, y + halfwidth_y, z + halfwidth_z]];
    this.vertex_values = this.vertices.map(figure);
    if (document.getElementById("input_marching_cubes").checked) {
        this.vertices_midpoint = (i, j) => vertices_midpoint(this, i, j);
        this.edge_midpoints = 
            [this.vertices_midpoint(0, 1), this.vertices_midpoint(1, 2), this.vertices_midpoint(2, 3), this.vertices_midpoint(3, 0),
             this.vertices_midpoint(4, 5), this.vertices_midpoint(5, 6), this.vertices_midpoint(6, 7), this.vertices_midpoint(7, 4),
             this.vertices_midpoint(0, 4), this.vertices_midpoint(1, 5), this.vertices_midpoint(2, 6), this.vertices_midpoint(3, 7)];
    }
}
function Tetrahedron(cube, i1, i2, i3, i4) {    // cubeにおける頂点i1,i2,i3,i4からなる四面体セル
    const ls = [i1, i2, i3, i4];
    this.vertices = ls.map(i => cube.vertices[i]);
    this.vertex_values = ls.map(i => cube.vertex_values[i]);
    this.vertices_midpoint = (i, j) => vertices_midpoint(this, i, j);
}

function draw() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // projection & camera position
    mat4.perspective(legacygl.uniforms.projection.value, Math.PI / 6, canvas.aspect_ratio(), 0.1, 1000);
    var modelview = legacygl.uniforms.modelview;
    camera.lookAt(modelview.value);
    // zx grid
    legacygl.color(0.5, 0.5, 0.5);
    drawutil.zxgrid(50);
    // draw
    resolution[0] = Number(document.getElementById("input_resolution_x").value);
    resolution[1] = Number(document.getElementById("input_resolution_y").value);
    resolution[2] = Number(document.getElementById("input_resolution_z").value);
    width = vec3.divide_ip(vec3.sub([], maxpoint, minpoint), resolution);
    for (var i = 0; i < resolution[0]; i++) {
        for (var j = 0; j < resolution[1]; j++) {
            for (var k = 0; k < resolution[2]; k++) {
                const x = width[0] * (i + 0.5) + minpoint[0];
                const y = width[1] * (j + 0.5) + minpoint[1];
                const z = width[2] * (k + 0.5) + minpoint[2];
                const centre = [x, y, z];
                const figure = 
                    document.getElementById("input_sphere").checked ? sphere :
                    document.getElementById("input_torus").checked ? torus : 
                    document.getElementById("input_cone").checked ? cone : 
                    document.getElementById("input_glass").checked ? glass : 
                    metaball;
                const cube = new Cube(centre, figure);
                if (document.getElementById("input_marching_cubes").checked) {    // Marching Cubes の場合
                    // https://www.youtube.com/watch?v=B_xk71YopsA を参考にした
                    // http://paulbourke.net/geometry/polygonise/ を参考にした
                    // 直方体セルの各頂点の関数値から、生成する面を決定
                    var index = 0;
                    for (var l = 0; l < 8; l++) {
                        index |= (cube.vertex_values[l] < 0 ? 1 : 0) << l;
                    }
                    const triangleList = triangleTableForCube[index];    // ./marching-cubes.js を参照すること
                    for (var m = 0; ; m += 3) {
                        if (triangleList[m] < 0) break;
                        if (document.getElementById("input_show_surface").checked) {
                            legacygl.color(0.9, 0.9, 0.2);
                            legacygl.begin(gl.TRIANGLES);
                            legacygl.vertex3(cube.edge_midpoints[triangleList[m]]);
                            legacygl.vertex3(cube.edge_midpoints[triangleList[m + 1]]);
                            legacygl.vertex3(cube.edge_midpoints[triangleList[m + 2]]);
                            legacygl.end();
                        }
                        if (document.getElementById("input_show_edges").checked) {
                            legacygl.color(1, 0.6, 0.2);
                            legacygl.begin(gl.LINE_STRIP);
                            legacygl.vertex3(cube.edge_midpoints[triangleList[m]]);
                            legacygl.vertex3(cube.edge_midpoints[triangleList[m + 1]]);
                            legacygl.vertex3(cube.edge_midpoints[triangleList[m + 2]]);
                            legacygl.end();
                        }
                    }
                } else if (document.getElementById("input_marching_tetrahedra").checked) {    // Marching Tetrahedra の場合
                    // http://paulbourke.net/geometry/polygonise/ を参考にした
                    // cubeを6つの四面体に分割
                    const generateTetrahedra = function(cube) {
                        return [new Tetrahedron(cube, 0, 2, 3, 7),
                                new Tetrahedron(cube, 0, 2, 6, 7),
                                new Tetrahedron(cube, 0, 4, 6, 7),
                                new Tetrahedron(cube, 0, 6, 1, 2),
                                new Tetrahedron(cube, 0, 6, 1, 4),
                                new Tetrahedron(cube, 5, 6, 1, 4)];  
                    };
                    const tetrahedra = generateTetrahedra(cube);
                    tetrahedra.forEach(function(t) {
                        // 四面体セルの各頂点の関数値から、生成する面を決定
                        var index = 0;
                        for (var l = 0; l < 4; l++) {
                            index |= (t.vertex_values[l] < 0 ? 1 : 0) << l;
                        }
                        const triangleList = [];
                        if (index == 1 || index == 14) {
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(0, 2));
                            triangleList.push(t.vertices_midpoint(0, 3));
                        } else if (index == 2 || index == 13) {
                            triangleList.push(t.vertices_midpoint(1, 2));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(1, 0));
                        } else if (index == 4 || index == 11) {
                            triangleList.push(t.vertices_midpoint(2, 3));
                            triangleList.push(t.vertices_midpoint(2, 0));
                            triangleList.push(t.vertices_midpoint(2, 1));
                        } else if (index == 7 || index == 8) {
                            triangleList.push(t.vertices_midpoint(3, 0));
                            triangleList.push(t.vertices_midpoint(3, 1));
                            triangleList.push(t.vertices_midpoint(3, 2));
                        } else if (index == 3 || index == 12) {
                            triangleList.push(t.vertices_midpoint(0, 3));
                            triangleList.push(t.vertices_midpoint(0, 2));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(1, 2));
                            triangleList.push(t.vertices_midpoint(0, 2));
                        } else if (index == 5 || index == 10) {
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(2, 3));
                            triangleList.push(t.vertices_midpoint(0, 3));
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(1, 2));
                            triangleList.push(t.vertices_midpoint(2, 3));
                        } else if (index == 6 || index == 9) {
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(2, 3));
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(0, 2));
                            triangleList.push(t.vertices_midpoint(2, 3));
                        }
                        for (var m = 0; ; m += 3) {
                            if (m >= triangleList.length) break;
                            if (document.getElementById("input_show_surface").checked) {
                                legacygl.color(0.9, 0.9, 0.2);
                                legacygl.begin(gl.TRIANGLES);
                                legacygl.vertex3(triangleList[m]);
                                legacygl.vertex3(triangleList[m + 1]);
                                legacygl.vertex3(triangleList[m + 2]);
                                legacygl.end();
                            }
                            if (document.getElementById("input_show_edges").checked) {
                                legacygl.color(1, 0.6, 0.2);
                                legacygl.begin(gl.LINE_STRIP);
                                legacygl.vertex3(triangleList[m]);
                                legacygl.vertex3(triangleList[m + 1]);
                                legacygl.vertex3(triangleList[m + 2]);
                                legacygl.end();
                            }   
                        }
                    });
                }
            }
        }
    }
}

function init() {
    // OpenGL context
    canvas = document.getElementById("canvas");
    gl = canvas.getContext("experimental-webgl");
    if (!gl)
        alert("Could not initialise WebGL, sorry :-(");
    var vertex_shader_src = "\
        attribute vec3 a_vertex;\
        attribute vec3 a_color;\
        varying vec3 v_color;\
        uniform mat4 u_modelview;\
        uniform mat4 u_projection;\
        void main(void) {\
            gl_Position = u_projection * u_modelview * vec4(a_vertex, 1.0);\
            v_color = a_color;\
            gl_PointSize = 5.0;\
        }\
        ";
    var fragment_shader_src = "\
        precision mediump float;\
        varying vec3 v_color;\
        void main(void) {\
            gl_FragColor = vec4(v_color, 1.0);\
        }\
        ";
    legacygl = get_legacygl(gl, vertex_shader_src, fragment_shader_src);
    legacygl.add_uniform("modelview", "Matrix4f");
    legacygl.add_uniform("projection", "Matrix4f");
    legacygl.add_vertex_attribute("color", 3);
    legacygl.vertex3 = function(p) {
        this.vertex(p[0], p[1], p[2]);
    };
    drawutil = get_drawutil(gl, legacygl);
    camera = get_camera(canvas.width);
    camera.eye = [15, 12, 20];
    // event handlers
    canvas.onmousedown = function(evt) {
        var mouse_win = this.get_mousepos(evt);
        camera.start_moving(mouse_win, evt.shiftKey ? "zoom" : evt.ctrlKey ? "pan" : "rotate");
    };
    canvas.onmousemove = function(evt) {
        var mouse_win = this.get_mousepos(evt);
        if (camera.is_moving()) {
            camera.move(mouse_win);
            draw();
        }
    };
    document.onmouseup = function (evt) {
        if (camera.is_moving()) {
            camera.finish_moving();
        }
    };
    // init OpenGL settings
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(1, 1, 1, 1);
};
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=MML_SVG"></script>
</head>
<body onload="init(); draw();">
  <h2><script type="text/javascript">document.write(document.getElementById("title").innerHTML);</script></h2>
  <canvas id="canvas" width="640" height="480" style="border:1px solid #000000"></canvas>
  <table>
    <tr>
      <td>Method:</td>
      <td>
        <input type="radio" name="input_method" id="input_marching_cubes" onchange="draw();" checked>Marching Cubes&emsp;
        <input type="radio" name="input_method" id="input_marching_tetrahedra" onchange="draw();">Marching Tetrahedra
      </td>
    </tr>
    <tr>
      <td>Figure:</td>
      <td>
        <input type="radio" name="input_figure" id="input_sphere" onchange="draw();" checked>sphere&ensp;
        <input type="radio" name="input_figure" id="input_torus" onchange="draw();">torus&ensp;
        <input type="radio" name="input_figure" id="input_cone" onchange="draw();">cone&ensp;
        <input type="radio" name="input_figure" id="input_glass" onchange="draw();">glass<br>
        <input type="radio" name="input_figure" id="input_metaball" onchange="draw();">metaball
      </td>
    </tr>
    <tr>
      <td>Resolution:</td>
      <td>
        <input type="number" id="input_resolution_x" onchange="draw();" min="2" step="1" value="10"><math><mo>&times;</mo></math>
        <input type="number" id="input_resolution_y" onchange="draw();" min="2" step="1" value="10"><math><mo>&times;</mo></math>
        <input type="number" id="input_resolution_z" onchange="draw();" min="2" step="1" value="10">
      </td>
    </tr>
    <tr>
      <td>Show Surface:</td>
      <td><input type="checkbox" id="input_show_surface" onchange="draw();" checked></td>
    </tr>
    <tr>
      <td>Show Edges:</td>
      <td><input type="checkbox" id="input_show_edges" onchange="draw();" checked></td>
    </tr>
  </table>
  <h3>Usage:</h3>
  <ul>
    <li>Drag: Camera Rotate</li>
    <li>Shift+drag: Camera Zoom</li>
    <li>Ctrl+drag: Camera Pan</li>
  </ul>
  
  <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
  <script src="https://button.glitch.me/button.js"></script>
</body>
</html>
