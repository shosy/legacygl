<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title id="title">Marching Cubes, Marching Tetrahedra</title>
<script src="https://cdn.rawgit.com/toji/gl-matrix/v3.3.0/dist/gl-matrix.js"></script>
<script src="https://legacygl-js.glitch.me/gl-matrix-util.js"></script>
<script src="https://legacygl-js.glitch.me/legacygl.js"></script>
<script src="https://legacygl-js.glitch.me/drawutil.js"></script>
<script src="https://legacygl-js.glitch.me/camera.js"></script>
<script src="https://legacygl-js.glitch.me/util.js"></script>
<script src="https://legacygl-js.glitch.me/glu.js"></script>
<script src="./marching-cubes.js"></script>
<script type="text/javascript">
var gl;
var canvas;
var legacygl;
var drawutil;
var camera;

// minpointからmaxpointまでの空間を解像度resolutionで分割
const minpoint = [-5.0, -5.0, -5.0];
const maxpoint = [5.0, 5.0, 5.0];
var resolution = new Array(3);    // 格子点の個数
var width = new Array(3);    // 格子点間の幅

// 図形一覧
function Figure(kind, f1, f2) {
    // if kind == 0, 関数f1に対して図形f1(p)<0
    // if kind == 1, 関数f1に対して図形f1(p)>=0
    // if kind == 2, 図形f1,f2に対してf1とf2の和集合
    // if kind == 3, 図形f1,f2に対してf1とf2の積集合
    // if kind == 4, 図形f1,f2に対してf1とf2の差集合
    this.kind = kind;
    this.f1 = f1;
    this.f2 = f2;
}
const sphere = new Figure(0, function(p){ return vec3.sqrLen(p) - 20.0 });
const torus = new Figure(0, function(p){ const R = 3.5, a = 1.0; const x = p[0], y = p[1], z = p[2]; return (x * x + y * y + z * z + R * R - a * a) ** 2 - 4.0 * R * R * (x * x + z * z) });
const cone = new Figure(0, function(p){ const x = p[0], y = p[1], z = p[2]; return x * x + z * z - 0.15 * (y - 5.0) * (y - 5.0) });
const wineglass = new Figure(0, function(p){ const x = p[0], y = p[1], z = p[2]; return x * x + z * z - Math.log(y + 5.1) ** 2 - 0.02 });
const far_metaballs = new Figure(0, function(p){ return 1.2 / vec3.dist(p, [-2.5, 0.5, 2.5]) + 1.2 / vec3.dist(p, [2.5, -1.5, -2.5]) - 1.0 });
const close_metaballs = new Figure(0, function(p){ return 1.2 / vec3.dist(p, [-1.5, 0.5, 1.5]) + 1.2 / vec3.dist(p, [1.5, -1.5, -1.5]) - 1.0 });
// const custom = new Figure(2,
//     new Figure(2,
//         new Figure(0, function(p){ const R = 4.0, a = 0.5; const x = p[0], y = p[1], z = p[2]; return (x * x + y * y + z * z + R * R - a * a) ** 2 - 4.0 * R * R * (x * x + y * y) }),
//         new Figure(0, function(p){ const R = 4.0, a = 0.5; const x = p[0], y = p[1], z = p[2]; return (x * x + y * y + z * z + R * R - a * a) ** 2 - 4.0 * R * R * (y * y + z * z) })),
//     new Figure(0, function(p){ const R = 4.0, a = 0.5; const x = p[0], y = p[1], z = p[2]; return (x * x + y * y + z * z + R * R - a * a) ** 2 - 4.0 * R * R * (z * z + x * x) }));
const custom = new Figure(3, cone, wineglass);

function calc_value(point, figure) {    // figureを表す陰関数の、点pointにおける値を計算
    if (figure.kind == 0) {
        return figure.f1(point);
    } else if (figure.kind == 1) {
        return -figure.f1(point);
    } else if (figure.kind == 2) {    // A or B のときは、minを取る
        return Math.min(calc_value(point, figure.f1), calc_value(point, figure.f2));
    } else if (figure.kind == 3) {    // A and B のときは、maxを取る
        return Math.max(calc_value(point, figure.f1), calc_value(point, figure.f2));
    } else if (figure.kind == 4) {    // A - B = A and (not B)
        return Math.max(calc_value(point, figure.f1), -calc_value(point, figure.f2));
    }
}

function interpolation(point1, point2, value1, value2) {    // 2点point1,point2を線形補間した点の座標
    if (value1 == value2) {
        return vec3.scale_ip(vec3.add([], point1, point2), 0.5);
    } else {
        return vec3.scale_ip(vec3.sub([], vec3.scale([], point2, value1), vec3.scale([], point1, value2)), 1.0 / (value1 - value2));
    }
}

function draw() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    // projection & camera position
    mat4.perspective(legacygl.uniforms.projection.value, Math.PI / 6, canvas.aspect_ratio(), 0.1, 1000);
    var modelview = legacygl.uniforms.modelview;
    camera.lookAt(modelview.value);
    // zx grid
    legacygl.color(0.5, 0.5, 0.5);
    drawutil.zxgrid(50);
    // draw
    resolution = [Number(document.getElementById("input_resolution_x").value), 
                  Number(document.getElementById("input_resolution_y").value),
                  Number(document.getElementById("input_resolution_z").value)]
    width = vec3.divide_ip(vec3.sub([], maxpoint, minpoint), resolution);
    const figure = 
        document.getElementById("input_sphere").checked ? sphere :
        document.getElementById("input_torus").checked ? torus : 
        document.getElementById("input_cone").checked ? cone : 
        document.getElementById("input_wineglass").checked ? wineglass :
        document.getElementById("input_far_metaballs").checked ? far_metaballs : 
        document.getElementById("input_close_metaballs").checked ? close_metaballs : 
        custom;
    const points = new Array(resolution[0] + 1);    // 各格子点の座標
    for (var i = 0; i <= resolution[0]; i++) {
        points[i] = new Array(resolution[1] + 1);
        for (var j = 0; j <= resolution[1]; j++) {
            points[i][j] = new Array(resolution[2] + 1);
            for (var k = 0; k <= resolution[2]; k++) {
                points[i][j][k] = vec3.add([], minpoint, vec3.mul([], [i, j, k], width));
            }
        }
    }
    const values = new Array(resolution[0] + 1);    // 各格子点の関数値
    for (var i = 0; i <= resolution[0]; i++) {
        values[i] = new Array(resolution[1] + 1);
        for (var j = 0; j <= resolution[1]; j++) {
            values[i][j] = new Array(resolution[2] + 1);
            for (var k = 0; k <= resolution[2]; k++) {
                values[i][j][k] = calc_value(points[i][j][k], figure);
            }
        }
    }
    for (var i = 0; i < resolution[0]; i++) {
        for (var j = 0; j < resolution[1]; j++) {
            for (var k = 0; k < resolution[2]; k++) {
                if (document.getElementById("input_marching_cubes").checked) {    // Marching Cubes の場合
                    // https://www.youtube.com/watch?v=B_xk71YopsA を参考にした
                    // http://paulbourke.net/geometry/polygonise/ を参考にした
                    // 直方体セルの各頂点の関数値から、生成する面を決定
                    const cube_points =    // セルの各頂点の座標
                        [points[i  ][j][k], points[i  ][j][k+1], points[i  ][j+1][k+1], points[i  ][j+1][k],
                         points[i+1][j][k], points[i+1][j][k+1], points[i+1][j+1][k+1], points[i+1][j+1][k]];
                    const cube_values =    // セルの各頂点の関数値
                        [values[i  ][j][k], values[i  ][j][k+1], values[i  ][j+1][k+1], values[i  ][j+1][k],
                         values[i+1][j][k], values[i+1][j][k+1], values[i+1][j+1][k+1], values[i+1][j+1][k]];
                    var index = 0;
                    for (var l = 0; l < 8; l++) {
                        index |= (cube_values[l] < 0 ? 1 : 0) << l;
                    }
                    const triangleIndexList = triangleTableForCube[index];    // ./marching-cubes.js を参照すること、edgeの番号
                    const trianglePointList = new Array();    // 三角形の座標のリスト
                    for (var m = 0; ; m++) {
                        if (triangleIndexList[m] < 0) {
                            break;
                        } else if (triangleIndexList[m] == 0) {
                            trianglePointList.push(interpolation(cube_points[0], cube_points[1], cube_values[0], cube_values[1]));
                        } else if (triangleIndexList[m] == 1) {
                            trianglePointList.push(interpolation(cube_points[1], cube_points[2], cube_values[1], cube_values[2]));
                        } else if (triangleIndexList[m] == 2) {
                            trianglePointList.push(interpolation(cube_points[2], cube_points[3], cube_values[2], cube_values[3]));
                        } else if (triangleIndexList[m] == 3) {
                            trianglePointList.push(interpolation(cube_points[3], cube_points[0], cube_values[3], cube_values[0]));
                        } else if (triangleIndexList[m] == 4) {
                            trianglePointList.push(interpolation(cube_points[4], cube_points[5], cube_values[4], cube_values[5]));
                        } else if (triangleIndexList[m] == 5) {
                            trianglePointList.push(interpolation(cube_points[5], cube_points[6], cube_values[5], cube_values[6]));
                        } else if (triangleIndexList[m] == 6) {
                            trianglePointList.push(interpolation(cube_points[6], cube_points[7], cube_values[6], cube_values[7]));
                        } else if (triangleIndexList[m] == 7) {
                            trianglePointList.push(interpolation(cube_points[7], cube_points[4], cube_values[7], cube_values[4]));
                        } else if (triangleIndexList[m] == 8) {
                            trianglePointList.push(interpolation(cube_points[0], cube_points[4], cube_values[0], cube_values[4]));
                        } else if (triangleIndexList[m] == 9) {
                            trianglePointList.push(interpolation(cube_points[1], cube_points[5], cube_values[1], cube_values[5]));
                        } else if (triangleIndexList[m] == 10) {
                            trianglePointList.push(interpolation(cube_points[2], cube_points[6], cube_values[2], cube_values[6]));
                        } else if (triangleIndexList[m] == 11) {
                            trianglePointList.push(interpolation(cube_points[3], cube_points[7], cube_values[3], cube_values[7]));
                        }
                    }
                    for (var m = 0; m < trianglePointList.length; m += 3) {
                        if (document.getElementById("input_show_surface").checked) {
                            legacygl.color(0.9, 0.9, 0.2);
                            legacygl.begin(gl.TRIANGLES);
                            legacygl.vertex3(trianglePointList[m]);
                            legacygl.vertex3(trianglePointList[m + 1]);
                            legacygl.vertex3(trianglePointList[m + 2]);
                            legacygl.end();
                        }
                        if (document.getElementById("input_show_edges").checked) {
                            legacygl.color(1, 0.6, 0.2);
                            legacygl.begin(gl.LINE_STRIP);
                            legacygl.vertex3(trianglePointList[m]);
                            legacygl.vertex3(trianglePointList[m + 1]);
                            legacygl.vertex3(trianglePointList[m + 2]);
                            legacygl.end();
                        }
                    }
                } /* else if (document.getElementById("input_marching_tetrahedra").checked) {    // Marching Tetrahedra の場合
                    // http://paulbourke.net/geometry/polygonise/ を参考にした
                    // cubeを6つの四面体に分割
                    const generateTetrahedra = function(cube) {
                        return [new Tetrahedron(cube, 0, 2, 3, 7),
                                new Tetrahedron(cube, 0, 2, 6, 7),
                                new Tetrahedron(cube, 0, 4, 6, 7),
                                new Tetrahedron(cube, 0, 6, 1, 2),
                                new Tetrahedron(cube, 0, 6, 1, 4),
                                new Tetrahedron(cube, 5, 6, 1, 4)];  
                    };
                    const tetrahedra = generateTetrahedra(cube);
                    tetrahedra.forEach(function(t) {
                        // 四面体セルの各頂点の関数値から、生成する面を決定
                        var index = 0;
                        for (var l = 0; l < 4; l++) {
                            index |= (t.vertex_values[l] < 0 ? 1 : 0) << l;
                        }
                        const triangleList = [];
                        if (index == 1 || index == 14) {
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(0, 2));
                            triangleList.push(t.vertices_midpoint(0, 3));
                        } else if (index == 2 || index == 13) {
                            triangleList.push(t.vertices_midpoint(1, 2));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(1, 0));
                        } else if (index == 4 || index == 11) {
                            triangleList.push(t.vertices_midpoint(2, 3));
                            triangleList.push(t.vertices_midpoint(2, 0));
                            triangleList.push(t.vertices_midpoint(2, 1));
                        } else if (index == 7 || index == 8) {
                            triangleList.push(t.vertices_midpoint(3, 0));
                            triangleList.push(t.vertices_midpoint(3, 1));
                            triangleList.push(t.vertices_midpoint(3, 2));
                        } else if (index == 3 || index == 12) {
                            triangleList.push(t.vertices_midpoint(0, 3));
                            triangleList.push(t.vertices_midpoint(0, 2));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(1, 2));
                            triangleList.push(t.vertices_midpoint(0, 2));
                        } else if (index == 5 || index == 10) {
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(2, 3));
                            triangleList.push(t.vertices_midpoint(0, 3));
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(1, 2));
                            triangleList.push(t.vertices_midpoint(2, 3));
                        } else if (index == 6 || index == 9) {
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(1, 3));
                            triangleList.push(t.vertices_midpoint(2, 3));
                            triangleList.push(t.vertices_midpoint(0, 1));
                            triangleList.push(t.vertices_midpoint(0, 2));
                            triangleList.push(t.vertices_midpoint(2, 3));
                        }
                        for (var m = 0; ; m += 3) {
                            if (m >= triangleList.length) break;
                            if (document.getElementById("input_show_surface").checked) {
                                legacygl.color(0.9, 0.9, 0.2);
                                legacygl.begin(gl.TRIANGLES);
                                legacygl.vertex3(triangleList[m]);
                                legacygl.vertex3(triangleList[m + 1]);
                                legacygl.vertex3(triangleList[m + 2]);
                                legacygl.end();
                            }
                            if (document.getElementById("input_show_edges").checked) {
                                legacygl.color(1, 0.6, 0.2);
                                legacygl.begin(gl.LINE_STRIP);
                                legacygl.vertex3(triangleList[m]);
                                legacygl.vertex3(triangleList[m + 1]);
                                legacygl.vertex3(triangleList[m + 2]);
                                legacygl.end();
                            }   
                        }
                    });
                }*/
            }
        }
    }
}

function init() {
    // OpenGL context
    canvas = document.getElementById("canvas");
    gl = canvas.getContext("experimental-webgl");
    if (!gl)
        alert("Could not initialise WebGL, sorry :-(");
    var vertex_shader_src = "\
        attribute vec3 a_vertex;\
        attribute vec3 a_color;\
        varying vec3 v_color;\
        uniform mat4 u_modelview;\
        uniform mat4 u_projection;\
        void main(void) {\
            gl_Position = u_projection * u_modelview * vec4(a_vertex, 1.0);\
            v_color = a_color;\
            gl_PointSize = 5.0;\
        }\
        ";
    var fragment_shader_src = "\
        precision mediump float;\
        varying vec3 v_color;\
        void main(void) {\
            gl_FragColor = vec4(v_color, 1.0);\
        }\
        ";
    legacygl = get_legacygl(gl, vertex_shader_src, fragment_shader_src);
    legacygl.add_uniform("modelview", "Matrix4f");
    legacygl.add_uniform("projection", "Matrix4f");
    legacygl.add_vertex_attribute("color", 3);
    legacygl.vertex3 = function(p) {
        this.vertex(p[0], p[1], p[2]);
    };
    drawutil = get_drawutil(gl, legacygl);
    camera = get_camera(canvas.width);
    camera.eye = [15, 12, 20];
    // event handlers
    canvas.onmousedown = function(evt) {
        var mouse_win = this.get_mousepos(evt);
        camera.start_moving(mouse_win, evt.shiftKey ? "zoom" : evt.ctrlKey ? "pan" : "rotate");
    };
    canvas.onmousemove = function(evt) {
        var mouse_win = this.get_mousepos(evt);
        if (camera.is_moving()) {
            camera.move(mouse_win);
            draw();
        }
    };
    document.onmouseup = function (evt) {
        if (camera.is_moving()) {
            camera.finish_moving();
        }
    };
    // init OpenGL settings
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(1, 1, 1, 1);
};
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=MML_SVG"></script>
</head>
<body onload="init(); draw();">
  <h2><script type="text/javascript">document.write(document.getElementById("title").innerHTML);</script></h2>
  <canvas id="canvas" width="640" height="480" style="border:1px solid #000000"></canvas>
  <table>
    <tr>
      <td>Method:</td>
      <td>
        <input type="radio" name="input_method" id="input_marching_cubes" onchange="draw();" checked>Marching Cubes&emsp;
        <input type="radio" name="input_method" id="input_marching_tetrahedra" onchange="draw();">Marching Tetrahedra
      </td>
    </tr>
    <tr>
      <td>Figure:</td>
      <td>
        <input type="radio" name="input_figure" id="input_sphere" onchange="draw();" checked>sphere&ensp;
        <input type="radio" name="input_figure" id="input_torus" onchange="draw();">torus&ensp;
        <input type="radio" name="input_figure" id="input_cone" onchange="draw();">cone&ensp;
        <input type="radio" name="input_figure" id="input_wineglass" onchange="draw();">wineglass<br>
        <input type="radio" name="input_figure" id="input_far_metaballs" onchange="draw();">far metaballs&ensp;
        <input type="radio" name="input_figure" id="input_close_metaballs" onchange="draw();">close metaballs<br>
        <input type="radio" name="input_figure" id="input_custom" onchange="draw();">custom
      </td>
    </tr>
    <tr>
      <td>Resolution:</td>
      <td>
        <input type="number" id="input_resolution_x" onchange="draw();" style="width:50px;" min="1" step="1" value="20"><math><mo>&times;</mo></math>
        <input type="number" id="input_resolution_y" onchange="draw();" style="width:50px;" min="1" step="1" value="20"><math><mo>&times;</mo></math>
        <input type="number" id="input_resolution_z" onchange="draw();" style="width:50px;" min="1" step="1" value="20">
      </td>
    </tr>
    <tr>
      <td>Show Surface:</td>
      <td><input type="checkbox" id="input_show_surface" onchange="draw();" checked></td>
    </tr>
    <tr>
      <td>Show Edges:</td>
      <td><input type="checkbox" id="input_show_edges" onchange="draw();" checked></td>
    </tr>
  </table>
  <h3>Usage:</h3>
  <ul>
    <li>Drag: Camera Rotate</li>
    <li>Shift+drag: Camera Zoom</li>
    <li>Ctrl+drag: Camera Pan</li>
  </ul>
  
  <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
  <script src="https://button.glitch.me/button.js"></script>
</body>
</html>
